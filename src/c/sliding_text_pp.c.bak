#include <pebble.h>
#include "num2words.h"

// ============================================================================
// ANIMATION STYLE CONFIGURATION
// ============================================================================
// Change ANIMATION_STYLE to switch between animation types:
//   - ANIMATION_STYLE_HACKER: Fast character-by-character random flashing
//   - ANIMATION_STYLE_SLIDE: Original sliding text animation
//
// To use the original slide animation, change the line below to:
//   #define ANIMATION_STYLE ANIMATION_STYLE_SLIDE
// ============================================================================

#define ANIMATION_STYLE_HACKER 1
#define ANIMATION_STYLE_SLIDE 0
#define ANIMATION_STYLE ANIMATION_STYLE_HACKER

// Hacker animation settings (only used when ANIMATION_STYLE == ANIMATION_STYLE_HACKER)
#define HACKER_ANIMATION_SPEED_MS 70  // How often to update (70ms for smooth effect)
#define HACKER_MAX_ITERATIONS 9       // Maximum random iterations per character
#define HACKER_MIN_ITERATIONS 4       // Minimum random iterations per character

enum WeatherKey {
  WEATHER_ICON_KEY = 0x0,
  WEATHER_TEMPERATURE_KEY = 0x1,
  WEATHER_CITY_KEY = 0x2,
};

// Persistent storage keys
#define PERSIST_WEATHER_CONDITION 100
#define PERSIST_WEATHER_TEMPERATURE 101

// BATTERY OPTIMIZATION STRATEGY:
// - Weather cached in persistent storage (loaded instantly on startup)
// - Only redraw when data actually changes (animation_update checks this)
// - Steps/battery only update when values change
// - Weather requested every 15 min (GPS cached 3 hrs in JS)

// Forward declarations
static void request_weather(void);
static void make_animation(void);
static void update_time_display(void);

typedef enum {
  MOVING_IN,
  IN_FRAME,
  PREPARE_TO_MOVE,
  MOVING_OUT
} SlideState;

// Hacker animation state for individual characters
typedef struct {
  char target_char;        // The final character we want to display
  char current_char;       // The current character being shown
  int iterations_left;     // How many more random iterations before locking
  bool locked;             // Whether this character has settled
} HackerCharState;

// Hacker animation state for a whole row
typedef struct {
  HackerCharState chars[64];  // Support up to 64 characters per line
  int target_length;          // Length of target string
  bool animating;             // Whether this row is currently animating
  char target_text[64];       // The text we're animating towards
  char display_buffer[64];    // Current display text (persistent)
} HackerRowState;

typedef struct {
  TextLayer *label;
  SlideState state; // animation state (for slide animation)
  char *next_string; // what to say in the next phase of animation
  bool unchanged_font;

  int left_pos;
  int right_pos;
  int still_pos;

  int movement_delay;
  int delay_count;
  
  // Hacker animation state
  HackerRowState hacker_state;
} SlidingRow;

typedef struct {
  TextLayer *demo_label;
  SlidingRow rows[4];
  SlidingRow date_row;  // separate row for the date part
  SlidingRow battery_row;  // battery percentage row
  SlidingRow weather_row;  // weather temperature row
  SlidingRow weather_condition_row;  // weather condition row
  SlidingRow steps_row;  // step count row
  int last_hour;
  int last_minute;
  int last_day;
  int last_battery;
  int last_temperature;
  int last_steps;
  int last_step_update_minute;  // Track when steps were last updated
  bool weather_changed;  // Flag to trigger collision re-check when weather updates

  GFont bitham42_bold;
  GFont bitham42_light;
  GFont gothic18_bold;
  GFont gothic18;

  Window *window;
  Animation *animation;
  AppTimer *hacker_timer;  // Timer for hacker animation updates

  struct SlidingTextRenderState {
    // double buffered string storage
    char hours[2][32];
    uint8_t next_hours;
    char first_minutes[2][32];
    char second_minutes[2][32];
    uint8_t next_minutes;
    char days[2][32];
    uint8_t next_days;
    char dates[2][32];
    uint8_t next_dates;
    char battery[2][64];
    uint8_t next_battery;
    char temperature[2][32];
    uint8_t next_temperature;
    char weather_condition[2][32];
    uint8_t next_weather_condition;
    char steps[2][32];
    uint8_t next_steps;

    struct SlidingTextRenderDemoTime {
      int secs;
      int mins;
      int hour;
    } demo_time;

  } render_state;

} SlidingTextData;

SlidingTextData *s_data;

static void day_to_word(int day, char *buffer) {
  const char *days[] = {"sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"};
  strcpy(buffer, days[day]);
}

static void day_to_abbreviated(int day, char *buffer) {
  const char *days_abbr[] = {"sun", "mon", "tue", "wed", "thu", "fri", "sat"};
  strcpy(buffer, days_abbr[day]);
}

static void date_to_words(int day, int month, char *buffer) {
  const char *months[] = {"january", "february", "march", "april", "may", "june",
                          "july", "august", "september", "october", "november", "december"};
  
  const char *suffix = "th";
  if (day == 1 || day == 21 || day == 31) suffix = "st";
  else if (day == 2 || day == 22) suffix = "nd";
  else if (day == 3 || day == 23) suffix = "rd";
  
  snprintf(buffer, 32, "%d%s %s", day, suffix, months[month]);
}

static void date_to_words_abbreviated(int day, int month, char *buffer) {
  const char *months_abbr[] = {"jan", "feb", "mar", "apr", "may", "jun",
                               "jul", "aug", "sep", "oct", "nov", "dec"};
  
  const char *suffix = "th";
  if (day == 1 || day == 21 || day == 31) suffix = "st";
  else if (day == 2 || day == 22) suffix = "nd";
  else if (day == 3 || day == 23) suffix = "rd";
  
  snprintf(buffer, 32, "%d%s %s", day, suffix, months_abbr[month]);
}

// Helper function to check if two text strings would collide based on actual pixel widths
static bool would_collide_with_font(const char *left_text, const char *right_text, GFont font, int screen_width) {
  if (!left_text || !right_text || strlen(left_text) == 0 || strlen(right_text) == 0) {
    return false;
  }
  
  // Calculate actual text widths in pixels
  GSize left_size = graphics_text_layout_get_content_size(left_text, font, 
    GRect(0, 0, screen_width, 100), GTextOverflowModeWordWrap, GTextAlignmentLeft);
  GSize right_size = graphics_text_layout_get_content_size(right_text, font,
    GRect(0, 0, screen_width, 100), GTextOverflowModeWordWrap, GTextAlignmentLeft);
  
  // Add some padding between texts (40 pixels for better safety)
  int padding = 40;
  return (left_size.w + right_size.w + padding) > screen_width;
}

// Helper to get screen width
static int get_screen_width(SlidingTextData *data) {
  Layer *window_layer = window_get_root_layer(data->window);
  return layer_get_bounds(window_layer).size.w;
}

static void number_to_words(int num, char *buffer) {
  const char *ones[] = {"", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
  const char *teens[] = {"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", 
                         "sixteen", "seventeen", "eighteen", "nineteen"};
  const char *tens[] = {"", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
  
  if (num == 0) {
    strcpy(buffer, "zero");
  } else if (num == 100) {
    strcpy(buffer, "one hundred");
  } else if (num < 10) {
    strcpy(buffer, ones[num]);
  } else if (num < 20) {
    strcpy(buffer, teens[num - 10]);
  } else if (num < 100) {
    int ten = num / 10;
    int one = num % 10;
    if (one == 0) {
      strcpy(buffer, tens[ten]);
    } else {
      snprintf(buffer, 64, "%s %s", tens[ten], ones[one]);
    }
  }
}

static void steps_to_significant_figure(int steps, char *buffer) {
  const char *ones[] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
  const char *teens[] = {"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", 
                         "sixteen", "seventeen", "eighteen", "nineteen"};
  const char *tens[] = {"", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
  
  if (steps == 0) {
    strcpy(buffer, "zero s");
  } else if (steps < 10) {
    // 1-9: "one s", "two s", etc.
    snprintf(buffer, 32, "%s s", ones[steps]);
  } else if (steps < 20) {
    // 10-19: round to nearest ten, display as "one ds" or "two ds"
    int rounded = (steps + 5) / 10;
    if (rounded == 1) {
      strcpy(buffer, "one ds");
    } else {
      strcpy(buffer, "two ds");
    }
  } else if (steps < 100) {
    // 20-99: round to nearest ten, display as "X ds"
    int rounded = (steps + 5) / 10;
    if (rounded < 10) {
      snprintf(buffer, 32, "%s ds", ones[rounded]);
    } else {
      strcpy(buffer, "ten ds");
    }
  } else if (steps < 1000) {
    // 100-999: round to nearest hundred, display as "X cs"
    int rounded = (steps + 50) / 100;
    if (rounded < 10) {
      snprintf(buffer, 32, "%s cs", ones[rounded]);
    } else {
      strcpy(buffer, "ten cs");
    }
  } else if (steps < 20000) {
    // 1000-19999: round to nearest thousand, display as "X ks"
    int rounded = (steps + 500) / 1000;
    if (rounded < 10) {
      snprintf(buffer, 32, "%s ks", ones[rounded]);
    } else if (rounded < 20) {
      snprintf(buffer, 32, "%s ks", teens[rounded - 10]);
    } else {
      strcpy(buffer, "twenty ks");
    }
  } else {
    // 20000+: round to nearest thousand, display as "X ks"
    int rounded = (steps + 500) / 1000;
    int ten = rounded / 10;
    int one = rounded % 10;
    if (one == 0) {
      snprintf(buffer, 32, "%s ks", tens[ten]);
    } else {
      snprintf(buffer, 32, "%s %s ks", tens[ten], ones[one]);
    }
  }
}

static void day_of_month_to_words(int day, char *buffer) {
  const char *tens[] = {"", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
  const char *firsts[] = {"first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth"};
  const char *teen_ths[] = {"tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth",
                            "sixteenth", "seventeenth", "eighteenth", "nineteenth"};
  const char *ten_ths[] = {"", "", "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth", "seventieth", "eightieth", "ninetieth"};
  
  if (day >= 1 && day <= 9) {
    strcpy(buffer, firsts[day - 1]);
  } else if (day >= 10 && day <= 19) {
    strcpy(buffer, teen_ths[day - 10]);
  } else if (day >= 20 && day <= 31) {
    int ten = day / 10;
    int one = day % 10;
    if (one == 0) {
      strcpy(buffer, ten_ths[ten]);
    } else {
      snprintf(buffer, 32, "%s %s", tens[ten], firsts[one - 1]);
    }
  } else {
    strcpy(buffer, "first");  // fallback
  }
}

// Generate a random visible ASCII character for hacker animation
static char get_random_char(void) {
  // Use only lowercase letters and numbers
  const char charset[] = "abcdefghijklmnopqrstuvwxyz0123456789";
  int charset_size = sizeof(charset) - 1;
  return charset[rand() % charset_size];
}

// Initialize hacker animation for a row with target text
static void start_hacker_animation(SlidingRow *row, const char *target_text, bool fast_mode) {
  HackerRowState *hstate = &row->hacker_state;
  
  APP_LOG(APP_LOG_LEVEL_INFO, "start_hacker_animation: '%s' (fast=%d)", target_text, fast_mode);
  
  // Check if we have existing text to transition from (reverse animation)
  const char *current_text = text_layer_get_text(row->label);
  bool has_existing = current_text && strlen(current_text) > 0;
  
  // Store target text
  strncpy(hstate->target_text, target_text, 63);
  hstate->target_text[63] = '\0';
  hstate->target_length = strlen(hstate->target_text);
  hstate->animating = true;
  
  // Use fewer iterations for fast mode (initial load)
  int min_iterations = fast_mode ? 1 : HACKER_MIN_ITERATIONS;
  int max_iterations = fast_mode ? 3 : HACKER_MAX_ITERATIONS;
  
  // Initialize each character's animation state
  for (int i = 0; i < hstate->target_length; i++) {
    hstate->chars[i].target_char = hstate->target_text[i];
    
    // Reverse animation: start with existing character if available
    if (has_existing && i < (int)strlen(current_text)) {
      hstate->chars[i].current_char = current_text[i];
      // If character is already correct, lock it immediately
      if (current_text[i] == hstate->target_text[i]) {
        hstate->chars[i].locked = true;
        hstate->chars[i].iterations_left = 0;
      } else {
        hstate->chars[i].locked = false;
      }
    } else {
      // No existing text, start with random
      hstate->chars[i].current_char = get_random_char();
      hstate->chars[i].locked = false;
    }
    
    if (!hstate->chars[i].locked) {
      // Progressive locking - earlier characters lock sooner (build left-to-right)
      int range = max_iterations - min_iterations;
      float progress = (float)i / (hstate->target_length > 1 ? hstate->target_length - 1 : 1);
      int base_iterations = min_iterations + (int)(progress * range);
      
      // Add slight randomness to avoid too mechanical feel
      int randomness = (rand() % 3) - 1; // -1, 0, or 1
      hstate->chars[i].iterations_left = base_iterations + randomness;
      if (hstate->chars[i].iterations_left < min_iterations) {
        hstate->chars[i].iterations_left = min_iterations;
      }
    }
    
    // Spaces always lock immediately
    if (hstate->target_text[i] == ' ') {
      hstate->chars[i].current_char = ' ';
      hstate->chars[i].locked = true;
      hstate->chars[i].iterations_left = 0;
    }
  }
}

// Update hacker animation - returns true if still animating
static bool update_hacker_animation(SlidingRow *row) {
  HackerRowState *hstate = &row->hacker_state;
  
  if (!hstate->animating) {
    return false;
  }
  
  bool any_unlocked = false;
  
  // Update each character directly in the persistent buffer
  for (int i = 0; i < hstate->target_length; i++) {
    if (hstate->chars[i].locked) {
      // Already locked, use target character
      hstate->display_buffer[i] = hstate->chars[i].target_char;
    } else {
      any_unlocked = true;
      
      if (hstate->chars[i].iterations_left <= 0) {
        // Time to lock this character
        hstate->chars[i].current_char = hstate->chars[i].target_char;
        hstate->chars[i].locked = true;
        hstate->display_buffer[i] = hstate->chars[i].target_char;
      } else {
        // Still randomizing - decrement and pick new random char
        hstate->chars[i].iterations_left--;
        hstate->chars[i].current_char = get_random_char();
        hstate->display_buffer[i] = hstate->chars[i].current_char;
      }
    }
  }
  
  hstate->display_buffer[hstate->target_length] = '\0';
  text_layer_set_text(row->label, hstate->display_buffer);
  layer_mark_dirty(text_layer_get_layer(row->label));  // Force redraw
  
  if (!any_unlocked) {
    hstate->animating = false;
    text_layer_set_text(row->label, hstate->target_text);
    layer_mark_dirty(text_layer_get_layer(row->label));  // Force final redraw
  }
  
  return any_unlocked;
}

static void init_sliding_row(SlidingTextData *data, SlidingRow *row, GRect pos, GFont font,
        int delay) {
  row->label = text_layer_create(pos);
  text_layer_set_text_alignment(row->label, PBL_IF_ROUND_ELSE(GTextAlignmentCenter, GTextAlignmentLeft));
  text_layer_set_background_color(row->label, GColorClear);
  text_layer_set_text_color(row->label, GColorWhite);
  if (font) {
    text_layer_set_font(row->label, font);
    row->unchanged_font = true;
  } else {
    row->unchanged_font = false;
  }

  row->state = IN_FRAME;
  row->next_string = NULL;

  row->left_pos = -pos.size.w;
  row->right_pos = pos.size.w;
  row->still_pos = pos.origin.x;

  row->movement_delay = delay;
  row->delay_count = 0;
  
  // Initialize hacker animation state
  row->hacker_state.animating = false;
  row->hacker_state.target_length = 0;
  memset(row->hacker_state.target_text, 0, sizeof(row->hacker_state.target_text));
  memset(row->hacker_state.display_buffer, 0, sizeof(row->hacker_state.display_buffer));
  
#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
  // For hacker animation, ensure layer is at correct position (not off-screen)
  GRect frame = layer_get_frame(text_layer_get_layer(row->label));
  frame.origin.x = row->still_pos;
  layer_set_frame(text_layer_get_layer(row->label), frame);
#endif

  data->last_hour = -1;
  data->last_minute = -1;
  data->last_day = -1;
  data->last_battery = -1;
  data->last_temperature = 999;
  data->last_steps = -1;
  data->last_step_update_minute = -1;
  data->weather_changed = false;
}

static void slide_in_text(SlidingTextData *data, SlidingRow *row, char* new_text) {
#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
  APP_LOG(APP_LOG_LEVEL_INFO, "slide_in_text: %s", new_text);
  // Use hacker animation (normal speed)
  start_hacker_animation(row, new_text, false);
  // Start the animation timer if not already running
  make_animation();
#else
  (void) data;
  // Use original slide animation
  const char *old_text = text_layer_get_text(row->label);
  if (old_text) {
    row->next_string = new_text;
    row->state = PREPARE_TO_MOVE;
  } else {
    text_layer_set_text(row->label, new_text);
    GRect frame = layer_get_frame(text_layer_get_layer(row->label));
    frame.origin.x = row->right_pos;
    layer_set_frame(text_layer_get_layer(row->label), frame);
    row->state = MOVING_IN;
  }
#endif
}


static bool update_sliding_row(SlidingTextData *data, SlidingRow *row) {
  (void) data;

#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
  // Use hacker animation
  return update_hacker_animation(row);
#else
  // Use original slide animation
  GRect frame = layer_get_frame(text_layer_get_layer(row->label));
  bool something_changed = true;
  switch (row->state) {
    case PREPARE_TO_MOVE:
      frame.origin.x = row->still_pos;
      row->delay_count++;
      if (row->delay_count > row->movement_delay) {
        row->state = MOVING_OUT;
        row->delay_count = 0;
      }
    break;

    case MOVING_IN: {
      int speed = abs(frame.origin.x - row->still_pos) / 3 + 1;
      frame.origin.x -= speed;
      if (frame.origin.x <= row->still_pos) {
        frame.origin.x = row->still_pos;
        row->state = IN_FRAME;
      }
    }
    break;

    case MOVING_OUT: {
      int speed = abs(frame.origin.x - row->still_pos) / 3 + 1;
      frame.origin.x -= speed;

      if (frame.origin.x <= row->left_pos) {
        frame.origin.x = row->right_pos;
        row->state = MOVING_IN;
        text_layer_set_text(row->label, row->next_string);
        row->next_string = NULL;
      }
    }
    break;

    case IN_FRAME:
    default:
      something_changed = false;
      break;
  }
  if (something_changed) {
    layer_set_frame(text_layer_get_layer(row->label), frame);
  }
  return something_changed;
#endif
}

#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
// Timer callback for hacker animation
static void hacker_animation_timer(void *data) {
  SlidingTextData *app_data = (SlidingTextData *)data;
  
  bool any_animating = false;
  
  // Update all rows
  any_animating |= update_sliding_row(app_data, &app_data->rows[0]);
  any_animating |= update_sliding_row(app_data, &app_data->rows[1]);
  any_animating |= update_sliding_row(app_data, &app_data->rows[2]);
  any_animating |= update_sliding_row(app_data, &app_data->rows[3]);
  any_animating |= update_sliding_row(app_data, &app_data->date_row);
  any_animating |= update_sliding_row(app_data, &app_data->battery_row);
  any_animating |= update_sliding_row(app_data, &app_data->weather_row);
  any_animating |= update_sliding_row(app_data, &app_data->weather_condition_row);
  any_animating |= update_sliding_row(app_data, &app_data->steps_row);
  
  // If still animating, schedule next update
  if (any_animating) {
    app_data->hacker_timer = app_timer_register(HACKER_ANIMATION_SPEED_MS, hacker_animation_timer, app_data);
  } else {
    app_data->hacker_timer = NULL;
  }
}
#endif

static void animation_update(struct Animation *animation, const AnimationProgress time_normalized) {
  SlidingTextData *data = s_data;

  struct SlidingTextRenderState *rs = &data->render_state;

  time_t now = time(NULL);
  struct tm t = *localtime(&now);

  bool something_changed = false;

  if (data->last_day != t.tm_wday || data->weather_changed) {
    something_changed = true;
    
    int screen_width = get_screen_width(data);
    
    // Update day - abbreviate if it would collide with temperature
    const char *temp_text = text_layer_get_text(data->weather_condition_row.label);
    char full_day[32];
    day_to_word(t.tm_wday, full_day);
    
    if (would_collide_with_font(temp_text, full_day, data->gothic18_bold, screen_width)) {
      day_to_abbreviated(t.tm_wday, rs->days[rs->next_days]);
    } else {
      strcpy(rs->days[rs->next_days], full_day);
    }
    
    // Update date - show only day of month, no month name
    // Use abbreviated format (just number) if full spelling would collide with conditions
    const char *cond_text = text_layer_get_text(data->weather_row.label);
    char full_date[32];
    day_of_month_to_words(t.tm_mday, full_date);
    
    if (would_collide_with_font(cond_text, full_date, data->gothic18, screen_width)) {
      // Use numeric format if spelled-out day is too long
      const char *suffix = "th";
      if (t.tm_mday == 1 || t.tm_mday == 21 || t.tm_mday == 31) suffix = "st";
      else if (t.tm_mday == 2 || t.tm_mday == 22) suffix = "nd";
      else if (t.tm_mday == 3 || t.tm_mday == 23) suffix = "rd";
      snprintf(rs->dates[rs->next_dates], 32, "%d%s", t.tm_mday, suffix);
    } else {
      strcpy(rs->dates[rs->next_dates], full_date);
    }
    
    if (data->last_day != t.tm_wday) {
      slide_in_text(data, &data->rows[0], rs->days[rs->next_days]);
      slide_in_text(data, &data->date_row, rs->dates[rs->next_dates]);
      rs->next_days = rs->next_days ? 0 : 1;
      rs->next_dates = rs->next_dates ? 0 : 1;
      data->last_day = t.tm_wday;
    }
    
    // Reset weather change flag after processing
    data->weather_changed = false;
    
    // Reset weather change flag after processing
    data->weather_changed = false;
  }

  if (data->last_minute != t.tm_min) {
    something_changed = true;

    minute_to_formal_words(t.tm_min, rs->first_minutes[rs->next_minutes], rs->second_minutes[rs->next_minutes]);
    
    // For minutes 1-9, minute_to_formal_words puts the word in first_word
    // We need to move it to second_word and put "oh" in first_word
    if (t.tm_min > 0 && t.tm_min < 10) {
      strcpy(rs->second_minutes[rs->next_minutes], rs->first_minutes[rs->next_minutes]);
      strcpy(rs->first_minutes[rs->next_minutes], "oh");
    }
    
    if(data->last_hour != t.tm_hour || t.tm_min <= 20
       || t.tm_min/10 != data->last_minute/10) {
      slide_in_text(data, &data->rows[2], rs->first_minutes[rs->next_minutes]);
    } else {
      // The tens line didn't change, so swap to the correct buffer but don't animate
      text_layer_set_text(data->rows[2].label, rs->first_minutes[rs->next_minutes]);
    }
    slide_in_text(data, &data->rows[3], rs->second_minutes[rs->next_minutes]);
    rs->next_minutes = rs->next_minutes ? 0 : 1;
    data->last_minute = t.tm_min;
  }

  if (data->last_hour != t.tm_hour) {
    hour_to_12h_word(t.tm_hour, rs->hours[rs->next_hours]);
    slide_in_text(data, &data->rows[1], rs->hours[rs->next_hours]);
    rs->next_hours = rs->next_hours ? 0 : 1;
    data->last_hour = t.tm_hour;
  }

  for (size_t i = 0; i < ARRAY_LENGTH(data->rows); ++i) {
    something_changed = update_sliding_row(data, &data->rows[i]) || something_changed;
  }
  something_changed = update_sliding_row(data, &data->date_row) || something_changed;
  something_changed = update_sliding_row(data, &data->battery_row) || something_changed;
  something_changed = update_sliding_row(data, &data->weather_row) || something_changed;
  something_changed = update_sliding_row(data, &data->weather_condition_row) || something_changed;
  something_changed = update_sliding_row(data, &data->steps_row) || something_changed;

  if (!something_changed) {
    animation_unschedule(data->animation);
  }
}

static void make_animation() {
#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
  APP_LOG(APP_LOG_LEVEL_INFO, "make_animation: starting timer");
  // For hacker animation, use timer-based updates
  // Cancel existing timer if any
  if (s_data->hacker_timer != NULL) {
    app_timer_cancel(s_data->hacker_timer);
  }
  // Start the hacker animation timer immediately
  s_data->hacker_timer = app_timer_register(10, hacker_animation_timer, s_data);
#else
  // Original slide animation
  s_data->animation = animation_create();
  animation_set_duration(s_data->animation, ANIMATION_DURATION_INFINITE);
  static const struct AnimationImplementation s_animation_implementation = {
    .update = animation_update,
  };
  animation_set_implementation(s_data->animation, &s_animation_implementation);
  animation_schedule(s_data->animation);
#endif
}

static void update_time_display(void) {
  SlidingTextData *data = s_data;
  struct SlidingTextRenderState *rs = &data->render_state;

  time_t now = time(NULL);
  struct tm t = *localtime(&now);

  // Check for day change
  if (data->last_day != t.tm_wday || data->weather_changed) {
    int screen_width = get_screen_width(data);
    
    // Update day - abbreviate if it would collide with temperature
    const char *temp_text = text_layer_get_text(data->weather_condition_row.label);
    char full_day[32];
    day_to_word(t.tm_wday, full_day);
    
    if (would_collide_with_font(temp_text, full_day, data->gothic18_bold, screen_width)) {
      day_to_abbreviated(t.tm_wday, rs->days[rs->next_days]);
    } else {
      strcpy(rs->days[rs->next_days], full_day);
    }
    
    // Update date - show only day of month, no month name
    const char *cond_text = text_layer_get_text(data->weather_row.label);
    char full_date[32];
    day_of_month_to_words(t.tm_mday, full_date);
    
    if (would_collide_with_font(cond_text, full_date, data->gothic18, screen_width)) {
      const char *suffix = "th";
      if (t.tm_mday == 1 || t.tm_mday == 21 || t.tm_mday == 31) suffix = "st";
      else if (t.tm_mday == 2 || t.tm_mday == 22) suffix = "nd";
      else if (t.tm_mday == 3 || t.tm_mday == 23) suffix = "rd";
      snprintf(rs->dates[rs->next_dates], 32, "%d%s", t.tm_mday, suffix);
    } else {
      strcpy(rs->dates[rs->next_dates], full_date);
    }
    
    if (data->last_day != t.tm_wday) {
      slide_in_text(data, &data->rows[0], rs->days[rs->next_days]);
      slide_in_text(data, &data->date_row, rs->dates[rs->next_dates]);
      rs->next_days = rs->next_days ? 0 : 1;
      rs->next_dates = rs->next_dates ? 0 : 1;
      data->last_day = t.tm_wday;
    }
    
    data->weather_changed = false;
  }

  // Check for minute change
  if (data->last_minute != t.tm_min) {
    APP_LOG(APP_LOG_LEVEL_INFO, "Minute changed: %d -> %d", data->last_minute, t.tm_min);
    minute_to_formal_words(t.tm_min, rs->first_minutes[rs->next_minutes], rs->second_minutes[rs->next_minutes]);
    
    // For minutes 1-9, move to second_word and put "oh" in first_word
    if (t.tm_min > 0 && t.tm_min < 10) {
      strcpy(rs->second_minutes[rs->next_minutes], rs->first_minutes[rs->next_minutes]);
      strcpy(rs->first_minutes[rs->next_minutes], "oh");
    }
    
    if(data->last_hour != t.tm_hour || t.tm_min <= 20
       || t.tm_min/10 != data->last_minute/10) {
      APP_LOG(APP_LOG_LEVEL_INFO, "Animating first mins: %s", rs->first_minutes[rs->next_minutes]);
      slide_in_text(data, &data->rows[2], rs->first_minutes[rs->next_minutes]);
    } else {
      APP_LOG(APP_LOG_LEVEL_INFO, "Direct set first mins: %s", rs->first_minutes[rs->next_minutes]);
      text_layer_set_text(data->rows[2].label, rs->first_minutes[rs->next_minutes]);
    }
    APP_LOG(APP_LOG_LEVEL_INFO, "Animating second mins: %s", rs->second_minutes[rs->next_minutes]);
    slide_in_text(data, &data->rows[3], rs->second_minutes[rs->next_minutes]);
    rs->next_minutes = rs->next_minutes ? 0 : 1;
    data->last_minute = t.tm_min;
  }

  // Check for hour change
  if (data->last_hour != t.tm_hour) {
    hour_to_12h_word(t.tm_hour, rs->hours[rs->next_hours]);
    slide_in_text(data, &data->rows[1], rs->hours[rs->next_hours]);
    rs->next_hours = rs->next_hours ? 0 : 1;
    data->last_hour = t.tm_hour;
  }
}

static void handle_minute_tick(struct tm *tick_time, TimeUnits units_changed) {
  update_time_display();
  make_animation();
  
  // Request weather every 30 minutes (JS handles caching)
  // Reduced from 15 to avoid too many requests
  if (tick_time->tm_min % 30 == 0) {
    request_weather();
  }
}

static void handle_battery(BatteryChargeState charge_state) {
  SlidingTextData *data = s_data;
  struct SlidingTextRenderState *rs = &data->render_state;
  
  int battery_percent = charge_state.charge_percent;
  
  if (data->last_battery != battery_percent) {
    char num_words[64];
    number_to_words(battery_percent, num_words);
    char battery_full[64];
    snprintf(battery_full, 64, "%s pc", num_words);
    
    int screen_width = get_screen_width(data);
    
    // Use compact format if battery text would collide with steps
    const char *steps_text = text_layer_get_text(data->steps_row.label);
    
    if (would_collide_with_font(steps_text, battery_full, data->gothic18, screen_width)) {
      snprintf(rs->battery[rs->next_battery], 64, "%d %%", battery_percent);
    } else {
      strcpy(rs->battery[rs->next_battery], battery_full);
    }
    
    slide_in_text(data, &data->battery_row, rs->battery[rs->next_battery]);
    rs->next_battery = rs->next_battery ? 0 : 1;
    data->last_battery = battery_percent;
    make_animation();
  }
}

static void health_handler(HealthEventType event, void *context) {
  SlidingTextData *data = s_data;
  struct SlidingTextRenderState *rs = &data->render_state;
  
  if (event == HealthEventMovementUpdate) {
    HealthMetric metric = HealthMetricStepCount;
    time_t start = time_start_of_today();
    time_t end = time(NULL);
    
    HealthServiceAccessibilityMask mask = health_service_metric_accessible(metric, start, end);
    
    if (mask & HealthServiceAccessibilityMaskAvailable) {
      int steps = (int)health_service_sum_today(metric);
      
      // Get current time to check if 5 minutes have passed
      time_t now = time(NULL);
      struct tm t = *localtime(&now);
      
      // Only update if steps changed AND at least 5 minutes have passed
      bool five_minutes_passed = (data->last_step_update_minute == -1) || 
                                  (abs(t.tm_min - data->last_step_update_minute) >= 5) ||
                                  (data->last_step_update_minute > t.tm_min && (60 - data->last_step_update_minute + t.tm_min) >= 5);
      
      if (data->last_steps != steps && five_minutes_passed) {
        steps_to_significant_figure(steps, rs->steps[rs->next_steps]);
        slide_in_text(data, &data->steps_row, rs->steps[rs->next_steps]);
        rs->next_steps = rs->next_steps ? 0 : 1;
        data->last_steps = steps;
        data->last_step_update_minute = t.tm_min;
        
        // Re-check battery collision when steps change
        BatteryChargeState battery_state = battery_state_service_peek();
        handle_battery(battery_state);
        
        make_animation();
      }
    }
  }
}

static void inbox_received_callback(DictionaryIterator *iterator, void *context) {
  SlidingTextData *data = s_data;
  struct SlidingTextRenderState *rs = &data->render_state;
  
  APP_LOG(APP_LOG_LEVEL_INFO, "Received message from phone");
  
  Tuple *temp_tuple = dict_find(iterator, WEATHER_TEMPERATURE_KEY);
  Tuple *condition_tuple = dict_find(iterator, WEATHER_CITY_KEY);
  
  if (temp_tuple) {
    int temperature = (int)temp_tuple->value->int32;
    APP_LOG(APP_LOG_LEVEL_INFO, "Temperature: %d", temperature);
    
    if (data->last_temperature != temperature) {
      // Convert temperature to words for top-left display
      char temp_words[32];
      number_to_words(temperature, temp_words);
      snprintf(rs->temperature[rs->next_temperature], 32, "%s c", temp_words);
      
      // Send temperature to weather_condition_row (top-left, bold)
      slide_in_text(data, &data->weather_condition_row, rs->temperature[rs->next_temperature]);
      rs->next_temperature = rs->next_temperature ? 0 : 1;
      data->last_temperature = temperature;
      
      // Cache temperature to persistent storage
      persist_write_int(PERSIST_WEATHER_TEMPERATURE, temperature);
      
      // Trigger day/date re-check for collision detection
      data->weather_changed = true;
      
      make_animation();
    }
  }
  
  if (condition_tuple) {
    APP_LOG(APP_LOG_LEVEL_INFO, "Condition: %s", condition_tuple->value->cstring);
    strncpy(rs->weather_condition[rs->next_weather_condition], condition_tuple->value->cstring, 31);
    rs->weather_condition[rs->next_weather_condition][31] = '\0';
    
    // Cache condition to persistent storage BEFORE incrementing buffer
    persist_write_string(PERSIST_WEATHER_CONDITION, rs->weather_condition[rs->next_weather_condition]);
    
    // Send conditions to weather_row (second-left)
    slide_in_text(data, &data->weather_row, rs->weather_condition[rs->next_weather_condition]);
    rs->next_weather_condition = rs->next_weather_condition ? 0 : 1;
    
    // Trigger day/date re-check for collision detection
    data->weather_changed = true;
    
    make_animation();
  }
}

static void inbox_dropped_callback(AppMessageResult reason, void *context) {
  APP_LOG(APP_LOG_LEVEL_ERROR, "Message dropped: %d", reason);
}

static void outbox_failed_callback(DictionaryIterator *iterator, AppMessageResult reason, void *context) {
  APP_LOG(APP_LOG_LEVEL_ERROR, "Outbox send failed: %d", reason);
}

static void outbox_sent_callback(DictionaryIterator *iterator, void *context) {
  APP_LOG(APP_LOG_LEVEL_INFO, "Outbox send success!");
}

static void request_weather(void) {
  DictionaryIterator *iter;
  app_message_outbox_begin(&iter);

  if (!iter) {
    return;
  }

  int value = 1;
  dict_write_int(iter, 1, &value, sizeof(int), true);
  dict_write_end(iter);

  app_message_outbox_send();
}

static void handle_deinit(void) {
  tick_timer_service_unsubscribe();
  battery_state_service_unsubscribe();
  #if defined(PBL_HEALTH)
  health_service_events_unsubscribe();
  #endif
  
#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
  // Cancel hacker animation timer if running
  if (s_data->hacker_timer != NULL) {
    app_timer_cancel(s_data->hacker_timer);
  }
#endif
  
  free(s_data);
}

static void handle_init() {
  SlidingTextData *data = (SlidingTextData*)malloc(sizeof(SlidingTextData));
  s_data = data;
  
  // Seed random number generator for hacker animation
  srand(time(NULL));
  
  // Initialize timer handle
  data->hacker_timer = NULL;

  data->render_state.next_hours = 0;
  data->render_state.next_minutes = 0;
  data->render_state.next_days = 0;
  data->render_state.next_dates = 0;
  data->render_state.next_battery = 0;
  data->render_state.next_temperature = 0;
  data->render_state.next_weather_condition = 0;
  data->render_state.next_steps = 0;
  data->render_state.demo_time.secs = 0;
  data->render_state.demo_time.mins = 0;
  data->render_state.demo_time.hour = 0;

  data->window = window_create();

  window_set_background_color(data->window, GColorBlack);

  data->bitham42_bold = fonts_get_system_font(FONT_KEY_BITHAM_42_BOLD);
  data->bitham42_light = fonts_get_system_font(FONT_KEY_BITHAM_42_LIGHT);
  data->gothic18_bold = fonts_get_system_font(FONT_KEY_GOTHIC_18_BOLD);
  data->gothic18 = fonts_get_system_font(FONT_KEY_GOTHIC_18);

  Layer *window_layer = window_get_root_layer(data->window);
  struct SlidingTextRenderState *rs = &data->render_state;
  GRect layer_frame = layer_get_frame(window_layer);
  const int16_t width = layer_frame.size.w;
  const int16_t padding = 5;

  init_sliding_row(data, &data->rows[0], GRect(2, -2, width - padding, 60), data->gothic18_bold, 6);
  text_layer_set_text_alignment(data->rows[0].label, PBL_IF_ROUND_ELSE(GTextAlignmentCenter, GTextAlignmentRight));
  layer_add_child(window_layer, text_layer_get_layer(data->rows[0].label));

  init_sliding_row(data, &data->date_row, GRect(2, 14, width - padding, 60), data->gothic18, 6);
  text_layer_set_text_alignment(data->date_row.label, PBL_IF_ROUND_ELSE(GTextAlignmentCenter, GTextAlignmentRight));
  layer_add_child(window_layer, text_layer_get_layer(data->date_row.label));

  init_sliding_row(data, &data->rows[1], GRect(2, 26, width, 60), data->bitham42_bold, 6);
  layer_add_child(window_layer, text_layer_get_layer(data->rows[1].label));

  init_sliding_row(data, &data->rows[2], GRect(2, 62, width, 96), data->bitham42_light, 3);
  layer_add_child(window_layer, text_layer_get_layer(data->rows[2].label));

  init_sliding_row(data, &data->rows[3], GRect(2, 98, width, 132), data->bitham42_light, 0);
  layer_add_child(window_layer, text_layer_get_layer(data->rows[3].label));
  init_sliding_row(data, &data->steps_row, GRect(2, 144, width / 2, 168), data->gothic18_bold, 6);
  text_layer_set_text_alignment(data->steps_row.label, GTextAlignmentLeft);
  layer_add_child(window_layer, text_layer_get_layer(data->steps_row.label));
  init_sliding_row(data, &data->battery_row, GRect(2, 144, width - padding, 168), data->gothic18, 6);
  text_layer_set_text_alignment(data->battery_row.label, PBL_IF_ROUND_ELSE(GTextAlignmentCenter, GTextAlignmentRight));
  layer_add_child(window_layer, text_layer_get_layer(data->battery_row.label));

  init_sliding_row(data, &data->weather_condition_row, GRect(2, -2, width / 2, 60), data->gothic18_bold, 6);
  text_layer_set_text_alignment(data->weather_condition_row.label, GTextAlignmentLeft);
  layer_add_child(window_layer, text_layer_get_layer(data->weather_condition_row.label));

  init_sliding_row(data, &data->weather_row, GRect(2, 14, width / 2, 60), data->gothic18, 6);
  text_layer_set_text_alignment(data->weather_row.label, GTextAlignmentLeft);
  layer_add_child(window_layer, text_layer_get_layer(data->weather_row.label));

  GFont norm14 = fonts_get_system_font(FONT_KEY_GOTHIC_14);

  data->demo_label = text_layer_create(GRect(0, -3, 100, 20));
  text_layer_set_background_color(data->demo_label, GColorClear);
  text_layer_set_text_color(data->demo_label, GColorWhite);
  text_layer_set_font(data->demo_label, norm14);
  text_layer_set_text(data->demo_label, "demo mode");
  layer_add_child(window_layer, text_layer_get_layer(data->demo_label));

  layer_set_hidden(text_layer_get_layer(data->demo_label), true);
  layer_mark_dirty(window_layer);

  // Load cached weather data
  // Temperature now goes to top-left (weather_condition_row), spelled out
  if (persist_exists(PERSIST_WEATHER_TEMPERATURE)) {
    int cached_temp = persist_read_int(PERSIST_WEATHER_TEMPERATURE);
    char temp_words[32];
    number_to_words(cached_temp, temp_words);
    snprintf(rs->temperature[rs->next_temperature], 32, "%s c", temp_words);
    
#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
    // Use hacker animation for initial load (fast mode)
    start_hacker_animation(&data->weather_condition_row, rs->temperature[rs->next_temperature], true);
#else
    text_layer_set_text(data->weather_condition_row.label, rs->temperature[rs->next_temperature]);
    data->weather_condition_row.state = IN_FRAME;
    // Ensure the layer is positioned at still_pos to prevent animation
    GRect frame = layer_get_frame(text_layer_get_layer(data->weather_condition_row.label));
    frame.origin.x = data->weather_condition_row.still_pos;
    layer_set_frame(text_layer_get_layer(data->weather_condition_row.label), frame);
#endif
    data->last_temperature = cached_temp;
  }
  
  // Condition now goes to second-left (weather_row)
  if (persist_exists(PERSIST_WEATHER_CONDITION)) {
    char cached_condition[32];
    persist_read_string(PERSIST_WEATHER_CONDITION, cached_condition, sizeof(cached_condition));
    strncpy(rs->weather_condition[rs->next_weather_condition], cached_condition, 31);
    rs->weather_condition[rs->next_weather_condition][31] = '\0';
    
#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
    // Use hacker animation for initial load (fast mode)
    start_hacker_animation(&data->weather_row, rs->weather_condition[rs->next_weather_condition], true);
#else
    text_layer_set_text(data->weather_row.label, rs->weather_condition[rs->next_weather_condition]);
    data->weather_row.state = IN_FRAME;
    // Ensure the layer is positioned at still_pos to prevent animation
    GRect frame = layer_get_frame(text_layer_get_layer(data->weather_row.label));
    frame.origin.x = data->weather_row.still_pos;
    layer_set_frame(text_layer_get_layer(data->weather_row.label), frame);
#endif
  }

  // Initialize time and date display on startup
  time_t now = time(NULL);
  struct tm t = *localtime(&now);
  
  // Set up initial time
  hour_to_12h_word(t.tm_hour, rs->hours[rs->next_hours]);
  minute_to_formal_words(t.tm_min, rs->first_minutes[rs->next_minutes], rs->second_minutes[rs->next_minutes]);
  
  // For minutes 1-9, move to second_word and put "oh" in first_word
  if (t.tm_min > 0 && t.tm_min < 10) {
    strcpy(rs->second_minutes[rs->next_minutes], rs->first_minutes[rs->next_minutes]);
    strcpy(rs->first_minutes[rs->next_minutes], "oh");
  }
  
  // Set up initial date
  day_to_word(t.tm_wday, rs->days[rs->next_days]);
  day_of_month_to_words(t.tm_mday, rs->dates[rs->next_dates]);
  
#if ANIMATION_STYLE == ANIMATION_STYLE_HACKER
  // Start hacker animations for time display
  // Use fast mode for day/date (smaller text), normal for time (more visible)
  start_hacker_animation(&data->rows[0], rs->days[rs->next_days], true);  // Day (fast)
  start_hacker_animation(&data->date_row, rs->dates[rs->next_dates], true);  // Date (fast)
  start_hacker_animation(&data->rows[1], rs->hours[rs->next_hours], false);  // Hour (normal - big text)
  start_hacker_animation(&data->rows[2], rs->first_minutes[rs->next_minutes], false);  // First minute (normal - big text)
  start_hacker_animation(&data->rows[3], rs->second_minutes[rs->next_minutes], false);  // Second minute (normal - big text)
#else
  // Set text directly for slide animation
  text_layer_set_text(data->rows[0].label, rs->days[rs->next_days]);
  text_layer_set_text(data->date_row.label, rs->dates[rs->next_dates]);
  text_layer_set_text(data->rows[1].label, rs->hours[rs->next_hours]);
  text_layer_set_text(data->rows[2].label, rs->first_minutes[rs->next_minutes]);
  text_layer_set_text(data->rows[3].label, rs->second_minutes[rs->next_minutes]);
#endif
  
  // Mark as initialized
  data->last_hour = t.tm_hour;
  data->last_minute = t.tm_min;
  data->last_day = t.tm_wday;

  make_animation();

  tick_timer_service_subscribe(MINUTE_UNIT, handle_minute_tick);
  battery_state_service_subscribe(handle_battery);
  handle_battery(battery_state_service_peek());

  // Subscribe to health events
  #if defined(PBL_HEALTH)
  health_service_events_subscribe(health_handler, NULL);
  // Get initial step count
  health_handler(HealthEventMovementUpdate, NULL);
  #endif

  // Setup AppMessage for weather
  app_message_register_inbox_received(inbox_received_callback);
  app_message_register_inbox_dropped(inbox_dropped_callback);
  app_message_register_outbox_failed(outbox_failed_callback);
  app_message_register_outbox_sent(outbox_sent_callback);
  app_message_open(256, 256);
  
  // Weather will update automatically every 15 minutes via handle_minute_tick
  // Cached data already loaded earlier to prevent slide-in animation

  const bool animated = true;
  window_stack_push(data->window, animated);
}

int main(void) {
  handle_init();

  app_event_loop();

  handle_deinit();
}
